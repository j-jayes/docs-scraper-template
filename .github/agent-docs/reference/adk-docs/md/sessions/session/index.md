Skip to content 

[ ](../.. "Agent Development Kit")

[ Agent Development Kit ](../.. "Agent Development Kit")

Overview 

Initializing search 




[ adk-python  ](https://github.com/google/adk-python "adk-python") [ adk-js  ](https://github.com/google/adk-js "adk-js") [ adk-go  ](https://github.com/google/adk-go "adk-go") [ adk-java  ](https://github.com/google/adk-java "adk-java")

[ adk-python  ](https://github.com/google/adk-python "adk-python") [ adk-js  ](https://github.com/google/adk-js "adk-js") [ adk-go  ](https://github.com/google/adk-go "adk-go") [ adk-java  ](https://github.com/google/adk-java "adk-java")

  * [ Home  ](../..)

Home 
  * Build Agents  Build Agents 
    * [ Get Started  ](../../get-started/)

Get Started 
      * [ Python  ](../../get-started/python/)
      * [ TypeScript  ](../../get-started/typescript/)
      * [ Go  ](../../get-started/go/)
      * [ Java  ](../../get-started/java/)
    * [ Build your Agent  ](../../tutorials/)

Build your Agent 
      * [ Multi-tool agent  ](../../get-started/quickstart/)
      * [ Agent team  ](../../tutorials/agent-team/)
      * [ Streaming agent  ](../../get-started/streaming/)

Streaming agent 
        * [ Python  ](../../get-started/streaming/quickstart-streaming/)
        * [ Java  ](../../get-started/streaming/quickstart-streaming-java/)
      * [ Visual Builder  ](../../visual-builder/)
      * [ Coding with AI  ](../../tutorials/coding-with-ai/)
      * [ Advanced setup  ](../../get-started/installation/)
    * [ Agents  ](../../agents/)

Agents 
      * [ LLM agents  ](../../agents/llm-agents/)
      * [ Workflow agents  ](../../agents/workflow-agents/)

Workflow agents 
        * [ Sequential agents  ](../../agents/workflow-agents/sequential-agents/)
        * [ Loop agents  ](../../agents/workflow-agents/loop-agents/)
        * [ Parallel agents  ](../../agents/workflow-agents/parallel-agents/)
      * [ Custom agents  ](../../agents/custom-agents/)
      * [ Multi-agent systems  ](../../agents/multi-agents/)
      * [ Agent Config  ](../../agents/config/)
      * [ Models & Authentication  ](../../agents/models/)
    * [ Tools for Agents  ](../../tools/)

Tools for Agents 
      * [ Gemini API tools  ](../../tools/gemini-api/)

Gemini API tools 
        * [ Code Execution  ](../../tools/gemini-api/code-execution/)
        * [ Computer use  ](../../tools/gemini-api/computer-use/)
        * [ Google Search  ](../../tools/gemini-api/google-search/)
      * [ Google Cloud tools  ](../../tools/google-cloud/)

Google Cloud tools 
        * [ Apigee API Hub  ](../../tools/google-cloud/apigee-api-hub/)
        * [ Application Integration  ](../../tools/google-cloud/application-integration/)
        * [ BigQuery  ](../../tools/google-cloud/bigquery/)
        * [ Bigtable  ](../../tools/google-cloud/bigtable/)
        * [ Cloud API Registry  ](../../tools/google-cloud/api-registry/)
        * [ Code Execution with Agent Engine  ](../../tools/google-cloud/code-exec-agent-engine/)
        * [ GKE Code Executor  ](../../tools/google-cloud/gke-code-executor/)
        * [ MCP Toolbox for Databases  ](../../tools/google-cloud/mcp-toolbox-for-databases/)
        * [ RAG Engine  ](../../tools/google-cloud/vertex-ai-rag-engine/)
        * [ Spanner  ](../../tools/google-cloud/spanner/)
        * [ Vertex AI Search  ](../../tools/google-cloud/vertex-ai-search/)
      * [ Third-party tools  ](../../tools/third-party/)

Third-party tools 
        * [ Atlassian  ](../../tools/third-party/atlassian/)
        * [ GitHub  ](../../tools/third-party/github/)
        * [ GitLab  ](../../tools/third-party/gitlab/)
        * [ Hugging Face  ](../../tools/third-party/hugging-face/)
        * [ Linear  ](../../tools/third-party/linear/)
        * [ n8n  ](../../tools/third-party/n8n/)
        * [ Notion  ](../../tools/third-party/notion/)
        * [ PayPal  ](../../tools/third-party/paypal/)
        * [ Qdrant  ](../../tools/third-party/qdrant/)
        * [ Agentic UI (AG-UI)  ](../../tools/third-party/ag-ui/)
      * [ Tool limitations  ](../../tools/limitations/)
    * [ Custom Tools  ](../../tools-custom/)

Custom Tools 
      * Function tools  Function tools 
        * [ Overview  ](../../tools-custom/function-tools/)
        * [ Tool performance  ](../../tools-custom/performance/)
        * [ Action confirmations  ](../../tools-custom/confirmation/)
      * [ MCP tools  ](../../tools-custom/mcp-tools/)
      * [ OpenAPI tools  ](../../tools-custom/openapi-tools/)
      * [ Authentication  ](../../tools-custom/authentication/)
  * Run Agents  Run Agents 
    * [ Agent Runtime  ](../../runtime/)

Agent Runtime 
      * [ Runtime Config  ](../../runtime/runconfig/)
      * [ API Server  ](../../runtime/api-server/)
      * [ Resume Agents  ](../../runtime/resume/)
    * [ Deployment  ](../../deploy/)

Deployment 
      * [ Agent Engine  ](../../deploy/agent-engine/)

Agent Engine 
        * [ Standard deployment  ](../../deploy/agent-engine/deploy/)
        * [ Agent Starter Pack  ](../../deploy/agent-engine/asp/)
        * [ Test deployed agents  ](../../deploy/agent-engine/test/)
      * [ Cloud Run  ](../../deploy/cloud-run/)
      * [ GKE  ](../../deploy/gke/)
    * Observability  Observability 
      * [ Logging  ](../../observability/logging/)
      * [ Cloud Trace  ](../../observability/cloud-trace/)
      * [ BigQuery Agent Analytics  ](../../observability/bigquery-agent-analytics/)
      * [ AgentOps  ](../../observability/agentops/)
      * [ Arize AX  ](../../observability/arize-ax/)
      * [ Freeplay  ](../../observability/freeplay/)
      * [ MLflow  ](../../observability/mlflow/)
      * [ Monocle  ](../../observability/monocle/)
      * [ Phoenix  ](../../observability/phoenix/)
      * [ W&B; Weave  ](../../observability/weave/)
    * [ Evaluation  ](../../evaluate/)

Evaluation 
      * [ Criteria  ](../../evaluate/criteria/)
      * [ User Simulation  ](../../evaluate/user-sim/)
    * [ Safety and Security  ](../../safety/)

Safety and Security 
  * Components  Components 
    * [ Technical Overview  ](../../get-started/about/)
    * [ Context  ](../../context/)

Context 
      * [ Context caching  ](../../context/caching/)
      * [ Context compression  ](../../context/compaction/)
    * [ Sessions & Memory  ](../)

Sessions & Memory 
      * Sessions  Sessions 
        * Overview  [ Overview  ](./) Table of contents 
          * The Session Object 
            * Example: Examining Session Properties 
          * Managing Sessions with a SessionService 
          * SessionService Implementations 
          * The Session Lifecycle 
        * [ Rewind sessions  ](../rewind/)
      * [ State  ](../state/)
      * [ Memory  ](../memory/)
      * [ Vertex AI Express Mode  ](../express-mode/)
    * [ Callbacks  ](../../callbacks/)

Callbacks 
      * [ Types of callbacks  ](../../callbacks/types-of-callbacks/)
      * [ Callback patterns  ](../../callbacks/design-patterns-and-best-practices/)
    * [ Artifacts  ](../../artifacts/)

Artifacts 
    * [ Events  ](../../events/)

Events 
    * [ Apps  ](../../apps/)

Apps 
    * [ Plugins  ](../../plugins/)

Plugins 
      * [ Reflect and retry  ](../../plugins/reflect-and-retry/)
    * [ MCP  ](../../mcp/)

MCP 
    * [ A2A Protocol  ](../../a2a/)

A2A Protocol 
      * [ Introduction to A2A  ](../../a2a/intro/)
      * A2A Quickstart (Exposing)  A2A Quickstart (Exposing) 
        * [ Python  ](../../a2a/quickstart-exposing/)
        * [ Go  ](../../a2a/quickstart-exposing-go/)
      * A2A Quickstart (Consuming)  A2A Quickstart (Consuming) 
        * [ Python  ](../../a2a/quickstart-consuming/)
        * [ Go  ](../../a2a/quickstart-consuming-go/)
    * [ Bidi-streaming (live)  ](../../streaming/)

Bidi-streaming (live) 
      * Bidi-streaming development guide series  Bidi-streaming development guide series 
        * [ Part 1. Intro to streaming  ](../../streaming/dev-guide/part1/)
        * [ Part 2. Sending messages  ](../../streaming/dev-guide/part2/)
        * [ Part 3. Event handling  ](../../streaming/dev-guide/part3/)
        * [ Part 4. Run configuration  ](../../streaming/dev-guide/part4/)
        * [ Part 5. Audio, Images, and Video  ](../../streaming/dev-guide/part5/)
      * [ Streaming Tools  ](../../streaming/streaming-tools/)
      * [ Configuring Bidi-streaming behavior  ](../../streaming/configuration/)
    * Grounding  Grounding 
      * [ Understanding Google Search Grounding  ](../../grounding/google_search_grounding/)
      * [ Understanding Vertex AI Search Grounding  ](../../grounding/vertex_ai_search_grounding/)
  * Reference  Reference 
    * [ Release Notes  ](../../release-notes/)
    * [ API Reference  ](../../api-reference/)

API Reference 
      * [ Python ADK  ](../../api-reference/python/)
      * [ Typescript ADK  ](../../api-reference/typescript/)
      * [ Go ADK  ](https://pkg.go.dev/google.golang.org/adk)
      * [ Java ADK  ](../../api-reference/java/)
      * [ CLI Reference  ](../../api-reference/cli/)
      * [ Agent Config Reference  ](../../api-reference/agentconfig/)
      * [ REST API  ](../../api-reference/rest/)
    * [ Community Resources  ](../../community/)
    * [ Contributing Guide  ](../../contributing-guide/)



Table of contents 

  * The Session Object 
    * Example: Examining Session Properties 
  * Managing Sessions with a SessionService 
  * SessionService Implementations 
  * The Session Lifecycle 



  1. [ Components  ](../../get-started/about/)
  2. [ Sessions & Memory  ](../)
  3. [ Sessions  ](./)

[ ](https://github.com/google/adk-docs/edit/main/docs/sessions/session.md "Edit this page") [ ](https://github.com/google/adk-docs/raw/main/docs/sessions/session.md "View source of this page")

# Session: Tracking Individual Conversations¶

Supported in ADKPython v0.1.0Typescript v0.2.0Go v0.1.0Java v0.1.0

Following our Introduction, let's dive into the `Session`. Think back to the idea of a "conversation thread." Just like you wouldn't start every text message from scratch, agents need context regarding the ongoing interaction. **`Session`** is the ADK object designed specifically to track and manage these individual conversation threads.

## The `Session` Object¶

When a user starts interacting with your agent, the `SessionService` creates a `Session` object (`google.adk.sessions.Session`). This object acts as the container holding everything related to that _one specific chat thread_. Here are its key properties:

  * **Identification (`id`, `appName`, `userId`):** Unique labels for the conversation.
    * `id`: A unique identifier for _this specific_ conversation thread, essential for retrieving it later. A SessionService object can handle multiple `Session`(s). This field identifies which particular session object are we referring to. For example, "test_id_modification".
    * `app_name`: Identifies which agent application this conversation belongs to. For example, "id_modifier_workflow".
    * `userId`: Links the conversation to a particular user.
  * **History (`events`):** A chronological sequence of all interactions (`Event` objects – user messages, agent responses, tool actions) that have occurred within this specific thread.
  * **Session State (`state`):** A place to store temporary data relevant _only_ to this specific, ongoing conversation. This acts as a scratchpad for the agent during the interaction. We will cover how to use and manage `state` in detail in the next section.
  * **Activity Tracking (`lastUpdateTime`):** A timestamp indicating the last time an event occurred in this conversation thread.



### Example: Examining Session Properties¶

PythonTypeScriptGoJava
    
    
     from google.adk.sessions import InMemorySessionService, Session
    
     # Create a simple session to examine its properties
     temp_service = InMemorySessionService()
     example_session = await temp_service.create_session(
         app_name="my_app",
         user_id="example_user",
         state={"initial_key": "initial_value"} # State can be initialized
     )
    
     print(f"--- Examining Session Properties ---")
     print(f"ID (`id`):                {example_session.id}")
     print(f"Application Name (`app_name`): {example_session.app_name}")
     print(f"User ID (`user_id`):         {example_session.user_id}")
     print(f"State (`state`):           {example_session.state}") # Note: Only shows initial state here
     print(f"Events (`events`):         {example_session.events}") # Initially empty
     print(f"Last Update (`last_update_time`): {example_session.last_update_time:.2f}")
     print(f"---------------------------------")
    
     # Clean up (optional for this example)
     temp_service = await temp_service.delete_session(app_name=example_session.app_name,
                                 user_id=example_session.user_id, session_id=example_session.id)
     print("The final status of temp_service - ", temp_service)
    
    
    
     import { InMemorySessionService } from "@google/adk";
    
     // Create a simple session to examine its properties
     const tempService = new InMemorySessionService();
     const exampleSession = await tempService.createSession({
         appName: "my_app",
         userId: "example_user",
         state: {"initial_key": "initial_value"} // State can be initialized
     });
    
     console.log("--- Examining Session Properties ---");
     console.log(`ID ('id'):                ${exampleSession.id}`);
     console.log(`Application Name ('appName'): ${exampleSession.appName}`);
     console.log(`User ID ('userId'):         ${exampleSession.userId}`);
     console.log(`State ('state'):           ${JSON.stringify(exampleSession.state)}`); // Note: Only shows initial state here
     console.log(`Events ('events'):         ${JSON.stringify(exampleSession.events)}`); // Initially empty
     console.log(`Last Update ('lastUpdateTime'): ${exampleSession.lastUpdateTime}`);
     console.log("---------------------------------");
    
     // Clean up (optional for this example)
     const finalStatus = await tempService.deleteSession({
         appName: exampleSession.appName,
         userId: exampleSession.userId,
         sessionId: exampleSession.id
     });
     console.log("The final status of temp_service - ", finalStatus);
    
    
    
    appName := "my_go_app"
    userID := "example_go_user"
    initialState := map[string]any{"initial_key": "initial_value"}
    
    // Create a session to examine its properties.
    createResp, err := inMemoryService.Create(ctx, &session.CreateRequest{
     AppName: appName,
     UserID:  userID,
     State:   initialState,
    })
    if err != nil {
     log.Fatalf("Failed to create session: %v", err)
    }
    exampleSession := createResp.Session
    
    fmt.Println("\n--- Examining Session Properties ---")
    fmt.Printf("ID (`ID()`): %s\n", exampleSession.ID())
    fmt.Printf("Application Name (`AppName()`): %s\n", exampleSession.AppName())
    // To access state, you call Get().
    val, _ := exampleSession.State().Get("initial_key")
    fmt.Printf("State (`State().Get()`):    initial_key = %v\n", val)
    
    // Events are initially empty.
    fmt.Printf("Events (`Events().Len()`):  %d\n", exampleSession.Events().Len())
    fmt.Printf("Last Update (`LastUpdateTime()`): %s\n", exampleSession.LastUpdateTime().Format("2006-01-02 15:04:05"))
    fmt.Println("---------------------------------")
    
    // Clean up the session.
    err = inMemoryService.Delete(ctx, &session.DeleteRequest{
     AppName:   exampleSession.AppName(),
     UserID:    exampleSession.UserID(),
     SessionID: exampleSession.ID(),
    })
    if err != nil {
     log.Fatalf("Failed to delete session: %v", err)
    }
    fmt.Println("Session deleted successfully.")
    
    
    
     import com.google.adk.sessions.InMemorySessionService;
     import com.google.adk.sessions.Session;
     import java.util.concurrent.ConcurrentMap;
     import java.util.concurrent.ConcurrentHashMap;
    
     String sessionId = "123";
     String appName = "example-app"; // Example app name
     String userId = "example-user"; // Example user id
     ConcurrentMap<String, Object> initialState = new ConcurrentHashMap<>(Map.of("newKey", "newValue"));
     InMemorySessionService exampleSessionService = new InMemorySessionService();
    
     // Create Session
     Session exampleSession = exampleSessionService.createSession(
         appName, userId, initialState, Optional.of(sessionId)).blockingGet();
     System.out.println("Session created successfully.");
    
     System.out.println("--- Examining Session Properties ---");
     System.out.printf("ID (`id`): %s%n", exampleSession.id());
     System.out.printf("Application Name (`appName`): %s%n", exampleSession.appName());
     System.out.printf("User ID (`userId`): %s%n", exampleSession.userId());
     System.out.printf("State (`state`): %s%n", exampleSession.state());
     System.out.println("------------------------------------");
    
    
     // Clean up (optional for this example)
     var unused = exampleSessionService.deleteSession(appName, userId, sessionId);
    

_(__Note:__The state shown above is only the initial state. State updates happen via events, as discussed in the State section.)_

## Managing Sessions with a `SessionService`¶

As seen above, you don't typically create or manage `Session` objects directly. Instead, you use a **`SessionService`**. This service acts as the central manager responsible for the entire lifecycle of your conversation sessions.

Its core responsibilities include:

  * **Starting New Conversations:** Creating fresh `Session` objects when a user begins an interaction.
  * **Resuming Existing Conversations:** Retrieving a specific `Session` (using its ID) so the agent can continue where it left off.
  * **Saving Progress:** Appending new interactions (`Event` objects) to a session's history. This is also the mechanism through which session `state` gets updated (more in the `State` section).
  * **Listing Conversations:** Finding the active session threads for a particular user and application.
  * **Cleaning Up:** Deleting `Session` objects and their associated data when conversations are finished or no longer needed.



## `SessionService` Implementations¶

ADK provides different `SessionService` implementations, allowing you to choose the storage backend that best suits your needs:

  1. **`InMemorySessionService`**

     * **How it works:** Stores all session data directly in the application's memory.
     * **Persistence:** None. **All conversation data is lost if the application restarts.**
     * **Requires:** Nothing extra.
     * **Best for:** Quick development, local testing, examples, and scenarios where long-term persistence isn't required.

PythonTypeScriptGoJava
    
    from google.adk.sessions import InMemorySessionService
     session_service = InMemorySessionService()
    
    
    import { InMemorySessionService } from "@google/adk";
     const sessionService = new InMemorySessionService();
    
    
    import "google.golang.org/adk/session"
    
     inMemoryService := session.InMemoryService()
    
    
    import com.google.adk.sessions.InMemorySessionService;
     InMemorySessionService exampleSessionService = new InMemorySessionService();
    

  2. **`VertexAiSessionService`**

Supported in ADKPython v0.1.0Go v0.1.0Java v0.1.0

     * **How it works:** Uses Google Cloud Vertex AI infrastructure via API calls for session management.
     * **Persistence:** Yes. Data is managed reliably and scalably via [Vertex AI Agent Engine](https://google.github.io/adk-docs/deploy/agent-engine/).
     * **Requires:**
       * A Google Cloud project (`pip install vertexai`)
       * A Google Cloud storage bucket that can be configured by this [step](https://cloud.google.com/vertex-ai/docs/pipelines/configure-project#storage).
       * A Reasoning Engine resource name/ID that can setup following this [tutorial](https://google.github.io/adk-docs/deploy/agent-engine/).
       * If you do not have a Google Cloud project and you want to try the VertexAiSessionService for free, see how to [try Session and Memory for free.](../express-mode/)
     * **Best for:** Scalable production applications deployed on Google Cloud, especially when integrating with other Vertex AI features.

PythonGoJava
    
    # Requires: pip install google-adk[vertexai]
    # Plus GCP setup and authentication
    from google.adk.sessions import VertexAiSessionService
    
    PROJECT_ID = "your-gcp-project-id"
    LOCATION = "us-central1"
    # The app_name used with this service should be the Reasoning Engine ID or name
    REASONING_ENGINE_APP_NAME = "projects/your-gcp-project-id/locations/us-central1/reasoningEngines/your-engine-id"
    
    session_service = VertexAiSessionService(project=PROJECT_ID, location=LOCATION)
    # Use REASONING_ENGINE_APP_NAME when calling service methods, e.g.:
    # session_service = await session_service.create_session(app_name=REASONING_ENGINE_APP_NAME, ...)
    
    
    import "google.golang.org/adk/session"
    
    // 2. VertexAIService
    // Before running, ensure your environment is authenticated:
    // gcloud auth application-default login
    // export GOOGLE_CLOUD_PROJECT="your-gcp-project-id"
    // export GOOGLE_CLOUD_LOCATION="your-gcp-location"
    
    modelName := "gemini-1.5-flash-001" // Replace with your desired model
    vertexService, err := session.VertexAIService(ctx, modelName)
    if err != nil {
      log.Printf("Could not initialize VertexAIService (this is expected if the gcloud project is not set): %v", err)
    } else {
      fmt.Println("Successfully initialized VertexAIService.")
    }
    
    
    // Please look at the set of requirements above, consequently export the following in your bashrc file:
    // export GOOGLE_CLOUD_PROJECT=my_gcp_project
    // export GOOGLE_CLOUD_LOCATION=us-central1
    // export GOOGLE_API_KEY=my_api_key
    
    import com.google.adk.sessions.VertexAiSessionService;
    import java.util.UUID;
    
    String sessionId = UUID.randomUUID().toString();
    String reasoningEngineAppName = "123456789";
    String userId = "u_123"; // Example user id
    ConcurrentMap<String, Object> initialState = new
        ConcurrentHashMap<>(); // No initial state needed for this example
    
    VertexAiSessionService sessionService = new VertexAiSessionService();
    Session mySession =
        sessionService
            .createSession(reasoningEngineAppName, userId, initialState, Optional.of(sessionId))
            .blockingGet();
    

  3. **`DatabaseSessionService`**

Supported in ADKPython v0.1.0Go v0.1.0

     * **How it works:** Connects to a relational database (e.g., PostgreSQL, MySQL, SQLite) to store session data persistently in tables.
     * **Persistence:** Yes. Data survives application restarts.
     * **Requires:** A configured database.
     * **Best for:** Applications needing reliable, persistent storage that you manage yourself.
    
    from google.adk.sessions import DatabaseSessionService
    # Example using a local SQLite file:
    # Note: The implementation requires an async database driver.
    # For SQLite, use 'sqlite+aiosqlite' instead of 'sqlite' to ensure async compatibility.
    db_url = "sqlite+aiosqlite:///./my_agent_data.db"
    session_service = DatabaseSessionService(db_url=db_url)
    

Async Driver Requirement

`DatabaseSessionService` requires an async database driver. When using SQLite, you must use `sqlite+aiosqlite` instead of `sqlite` in your connection string. For other databases (PostgreSQL, MySQL), ensure you're using an async-compatible driver (e.g., `asyncpg` for PostgreSQL, `aiomysql` for MySQL).




Choosing the right `SessionService` is key to defining how your agent's conversation history and temporary data are stored and persist.

## The Session Lifecycle¶

Here’s a simplified flow of how `Session` and `SessionService` work together during a conversation turn:

  1. **Start or Resume:** Your application needs to use the `SessionService` to either `create_session` (for a new chat) or use an existing session id.
  2. **Context Provided:** The `Runner` gets the appropriate `Session` object from the appropriate service method, providing the agent with access to the corresponding Session's `state` and `events`.
  3. **Agent Processing:** The user prompts the agent with a query. The agent analyzes the query and potentially the session `state` and `events` history to determine the response.
  4. **Response & State Update:** The agent generates a response (and potentially flags data to be updated in the `state`). The `Runner` packages this as an `Event`.
  5. **Save Interaction:** The `Runner` calls `sessionService.append_event(session, event)` with the `session` and the new `event` as the arguments. The service adds the `Event` to the history and updates the session's `state` in storage based on information within the event. The session's `last_update_time` also get updated.
  6. **Ready for Next:** The agent's response goes to the user. The updated `Session` is now stored by the `SessionService`, ready for the next turn (which restarts the cycle at step 1, usually with the continuation of the conversation in the current session).
  7. **End Conversation:** When the conversation is over, your application calls `sessionService.delete_session(...)` to clean up the stored session data if it is no longer required.



This cycle highlights how the `SessionService` ensures conversational continuity by managing the history and state associated with each `Session` object.

Back to top  [ Previous  Introduction to Conversational Context: Session, State, and Memory  ](../) [ Next  Rewind sessions  ](../rewind/)

Copyright Google 2025  |  [Terms](//policies.google.com/terms)  |  [Privacy](//policies.google.com/privacy)  |  Manage cookies

Made with [ Material for MkDocs ](https://squidfunk.github.io/mkdocs-material/)

#### Cookie consent

We use cookies to recognize repeated visits and preferences, as well as to measure the effectiveness of our documentation and whether users find the information they need. With your consent, you're helping us to make our documentation better.

  * Google Analytics 
  * GitHub 



Accept Manage settings
